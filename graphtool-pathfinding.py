import graph_tool.all as gt
import sys
import os
import gc
import timeit
from memory_profiler import profile
import multiprocessing

#from graph_tool.all import *


"""
import random
import math
import pandas as pd
import networkx as nx
import pylab
from pylab import rcParams

import functools


from memory_profiler import memory_usage
from memory_profiler import LogFile
import guppy
import multiprocessing
"""


"""
Program to read the small-world graphs generated by the graph generator script. 
It then loads the maps, one by one, into NetworkX to calculate 
shortest paths.

Pipe the output to text file for subsequent parsing and reporting of the results.

For reference, see:
http://stackoverflow.com/questions/6667201/how-to-define-two-dimensional-array-in-python
and
http://stackoverflow.com/questions/29192644/passing-a-multidimensional-array-to-a-function-in-python
and
http://stackoverflow.com/questions/29572623/plot-networkx-graph-from-adjacency-matrix-in-csv-file#29574772
and
http://stackoverflow.com/questions/5086430/how-to-pass-parameters-of-a-function-when-using-timeit-timer
"""



############################################################
def isNotEmpty(s):
    return bool(s and s.strip())


############################################################
def createFilePath( fileName, path, debug=False):

    #get path to this running Python script:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    if debug: print("script_dir = %s" % script_dir)
    
    #get path to output path + file:
    dest_dir = os.path.join(script_dir, path)
    if debug: print("dest_dir = %s" % dest_dir)
    
    #attempt to make the directory, if it doesn't already exist:
    try:
        os.makedirs(dest_dir)
        if debug: print("created directory: %s" % dest_dir)
    except OSError:
        if debug: print("directory already exists?: %s" % dest_dir )
        pass    #path already exists

    finalPathFileName = os.path.join( dest_dir, fileName )
    return finalPathFileName


############################################################
def checkFilePath( fileName, path, debug=False):

    #get path to this running Python script:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    if debug: print("script_dir = %s" % script_dir)
    
    #get path to output path + file:
    dest_dir = os.path.join(script_dir, path)
    if debug: print("dest_dir = %s" % dest_dir)
    
    #does path exist?
    if os.path.exists(dest_dir):
        
        #does target file exist?
        targetFile = os.path.join (dest_dir, fileName)
        if os.path.isfile(targetFile):
            if debug: print("found target file %s" % targetFile)
            return True
        else:
            print("target file %s does not exist." % targetFile)
            return False
    else: 
        print("path %s does not exist." % dest_dir)
        return False


############################################################
def checkPath( path, debug=False):

    #get path to this running Python script:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    if debug: print("script_dir = %s" % script_dir)
    
    #get path to input path:
    input_dir = os.path.join(script_dir, path)
    if debug: print("target dir = %s" % input_dir)
    
    #does path exist?
    if os.path.exists(input_dir):
        
        if debug: print("found target input path %s" % input_dir)
        return True
        
    else: 
        print("Path %s does not exist." % input_dir)
        return False


"""
############################################################
# NetworkX graph manipulations
#
# This function takes a simple adjacency matrix CSV file name as input.
# The adjacency matrix itself should have no label/column/row headers.
# It just needs the connection data, comma-delimited values. 
# E.g., an example of 3x3 adjacency matrix file contents:
#
#       1,0,0
#       0,1,1
#       1,0,0
#
# Warning: if showGraph is True, it will display the graphs, but one-by-one. You
# would have to serially close each graph window, for the next one to be generated
# and then be displayed, so you could then close that one... ad infinitum.
# So, set the showGraph parameter to true, only during testing.
#
# The pathfinding algorithm parameter accepts a 1, 2, or 3, 
# which (alphabetical order) indicates the following:
#   1 = A* (A-star) algorithm   <--- this is the default
#   2 = Bellman-Ford algorithm
#   3 = Dijkstra's algorithm
#
def performNetworkXCalculations(adjMatrixFileName, path, algorithm=1, viewWidth=10, viewHeight=10, showGraph=False, debug=False):

    algorithm = int(algorithm)
    viewWidth = int(viewWidth)
    viewHeight = int(viewHeight)
    showGraph = bool(showGraph)
    debug = bool(debug)

    if debug: print("Performing NetworkX pathfinding calculations...")

    #boundary checking:
    if viewWidth < 0 or viewWidth > 16: viewWidth = 10
    if viewHeight < 0 or viewHeight > 10: viewHeight = 10
    if algorithm < 1: algorithm = 1
    if algorithm > 3: algorithm = 3

    csvPathFile = os.path.join(path, adjMatrixFileName)

    #read adjacency matrix file into pandas:
    input_data = pd.read_csv(csvPathFile, header=None)
    #if debug: print ("\nPandas: input_data = \n%s" % input_data)

    start_time = 0.0

    #Now calculate the shortest paths, based on the user-specified algorithm.
    if algorithm == 1:
        if debug: print("Algorithm: A-Star")
        print("RESULTS|A-star|memoryConsumption(MB)|...\n")
        start_time = timeit.default_timer() #get the start time

        manager = multiprocessing.Manager()
        state = manager.list()
        state.append({})
        args = state[0]
        args["input_data"] = input_data
        args["debug"] = debug
        state[0] = args
        
        #start_time = timeit.default_timer() #get the start time
        #runAstar(G, startNode, destNode)
        p = multiprocessing.Process(target=runAstar, args=(state,) )
        p.start()
        p.join() #wait for child process to finish.
        print("RESULTS|A-star|pathLength|%d" % int(state[0]["pathLength"]) )
        print("RESULTS|A-star|path|%s" % str(state[0]["path"]) )

        end_time = timeit.default_timer() #get the end time
        elapsed_time = end_time - start_time

    elif algorithm == 2:
        if debug: print("Algorithm: Bellman-Ford")
        print("RESULTS|Bellman-Ford|memoryConsumption(MB)|...\n")
        start_time = timeit.default_timer() #get the start time

        manager = multiprocessing.Manager()
        state = manager.list()
        state.append({})
        args = state[0]
        args["input_data"] = input_data
        args["debug"] = debug
        state[0] = args
        
        #start_time = timeit.default_timer() #get the start time
        #runBellmanFord(G, startNode, destNode)
        p = multiprocessing.Process(target=runBellmanFord, args=(state,) )
        p.start()
        p.join() #wait for child process to finish.
        print("RESULTS|Bellman-Ford|pathLength|%d" % int(state[0]["pathLength"]) )
        print("RESULTS|Bellman-Ford|path|%s" % str(state[0]["path"]) )

        end_time = timeit.default_timer() #get the end time
        elapsed_time = end_time - start_time

    elif algorithm == 3:
        if debug: print("Algorithm: Dijkstra")
        print("RESULTS|Dijkstra|memoryConsumption(MB)|...\n")
        start_time = timeit.default_timer() #get the start time

        manager = multiprocessing.Manager()
        state = manager.list()
        state.append({})
        args = state[0]
        args["input_data"] = input_data
        args["debug"] = debug
        state[0] = args
        
        #start_time = timeit.default_timer() #get the start time
        #runDijkstra(G, startNode, destNode)
        p = multiprocessing.Process(target=runDijkstra, args=(state,) )
        p.start()
        p.join() #wait for child process to finish.
        print("RESULTS|Dijkstra|pathLength|%d" % int(state[0]["pathLength"]) )
        print("RESULTS|Dijkstra|path|%s" % str(state[0]["path"]) )

        end_time = timeit.default_timer() #get the end time
        elapsed_time = end_time - start_time

    if showGraph == True:
        #Prepare the graphical display. Set graph display to x,y screen inches:
        rcParams['figure.figsize'] = viewWidth, viewHeight
        G = nx.Graph( input_data.values ) 
        nx.draw_circular(G, with_labels=True) #draw circular graph
        #nx.draw(G, with_labels=True)
        #nx.draw_spectral(G, with_labels=True)
        #nx.draw_spring(G, with_labels=True)
        #nx.draw_shell(G, with_labels=True)
        #nx.draw_networkx(G, with_labels=True)
        #nx.draw_random(G, with_labels=True)
        pylab.show() #show the graph to screen for viewing

    #cleanup:
    del input_data
    del csvPathFile
    
    #Done:
    return elapsed_time


############################################################
#
# The A-Star wrapper function
#
# This has been broken out of NetworkX function to make timing calculations
# more fine-grained and unique to the graph algorithm itself, not the 
# support code that loads the map and instantiates variables.
#
# This function is run as a separate process, to permit collection of memory
# consumption data due to complexity with the Python memory manager
# vs the OS memory manager. See the following links for details:
#
# http://stackoverflow.com/questions/23937189/how-do-i-use-subprocesses-to-force-python-to-release-memory/24126616#24126616
# https://docs.python.org/2/library/multiprocessing.html
# http://deeplearning.net/software/theano/tutorial/python-memory-management.html
#
@profile(precision=4)
def runAstar(state):

    input_data = state[0]["input_data"]
    debug = state[0]["debug"]

    #load NetworkX with adjacency matrix graph data (via Pandas)
    #G = nx.DiGraph( input_data.values ) #for directed graphs
    G = nx.Graph( input_data.values )  #for undirected graphs

    #Get list of nodes:
    nodeList = G.nodes()
    #nodeListData = G.nodes(data=True)
    #if debug: print("Node list length: %d" % len(nodeListData) )
    if debug: print("Node list length: %d" % len(nodeList) )

    #determine start and destination nodes for pathfinding purposes
    startNode = 1 #start node will always be node 1.
    #destNode = len(nodeListData)/2 + 1 #destination node will always be in the middle.
    destNode = len(nodeList)/2 + 1 #destination node will always be in the middle.
    #if debug: print ("Number of nodes in this graph: %d" % len(nodeListData) )
    #if debug: print ("Number of nodes in this graph: %d" % len(nodeList) )
    if debug: print ("Start node: %d.  Destination node: %d." % (startNode, destNode) )

    aStarPath = nx.astar_path(G, startNode, destNode )
    #aStarPathLength = nx.astar_path_length(G, startNode, destNode )
    aStarPathLength = len(aStarPath)

    #Return results by loading the list shared between processes.
    state.append({})
    args = state[0]
    args["pathLength"] = aStarPathLength
    args["path"] = aStarPath
    state[0] = args


############################################################
#
# The Bellman-Ford wrapper function
##
# This has been broken out of NetworkX function to make timing calculations
# more fine-grained and unique to the graph algorithm itself, not the 
# support code that loads the map and instantiates variables.
#
# This function is run as a separate process, to permit collection of memory
# consumption data due to complexity with the Python memory manager
# vs the OS memory manager. See the following links for details:
#
# http://stackoverflow.com/questions/23937189/how-do-i-use-subprocesses-to-force-python-to-release-memory/24126616#24126616
# https://docs.python.org/2/library/multiprocessing.html
# http://deeplearning.net/software/theano/tutorial/python-memory-management.html
#
@profile(precision=4)
def runBellmanFord(state):

    input_data = state[0]["input_data"]
    debug = state[0]["debug"]

    #load NetworkX with adjacency matrix graph data (via Pandas)
    #G = nx.DiGraph( input_data.values ) #for directed graphs
    G = nx.Graph( input_data.values )  #for undirected graphs

    #Get list of nodes:
    nodeList = G.nodes()
    #nodeListData = G.nodes(data=True)
    #if debug: print("Node list length: %d" % len(nodeListData) )
    if debug: print("Node list length: %d" % len(nodeList) )

    #determine start and destination nodes for pathfinding purposes
    startNode = 1 #start node will always be node 1.
    #destNode = len(nodeListData)/2 + 1 #destination node will always be in the middle.
    destNode = len(nodeList)/2 + 1 #destination node will always be in the middle.
    #if debug: print ("Number of nodes in this graph: %d" % len(nodeListData) )
    if debug: print ("Start node: %d.  Destination node: %d." % (startNode, destNode) )

    pred, dist = nx.bellman_ford(G, startNode )
    #print ("bellmanFord: pred = %s") % sorted(pred.items())
    #print ("bellmanFord: dist = %s") % sorted(dist.items())

    #1/2. NetworkX's Bellman-Ford method doesn't return a simple path, nor
    # a path length, like the A* and Dijkstra versions. It instead returns 
    # two lists: a predecessor, and a distance list.
    # So, we must do some list traversal to find the desired values that are
    # equivalent to the ones supported by A* and Dijkstra method versions:
    bfPath = [destNode] #start with destination node
    path = dict(pred) #convert predecessor list to K-V dictionary
    currNode = destNode #set current node to destination node
    #The following loop will start from the destination and work our way back to 
    # the start node, one node link at a time:
    while currNode != startNode:  #start with destination node...
        bfPath.append( path[currNode] ) #append the predecessor node...
        currNode = path[currNode] #update the current node... keep looping backwards.
    bfPath.reverse() #now reverse the list, so it displays in correct order
    #print("bellmanFordPath = %s" % bfpath)

    #2/2. For Bellman-Ford distance, convert the dist list into a K-V dictionary, 
    # then search the dictionary for the destination node, 
    # then get that list entry's associated value.
    # This value represents the Bellman-Ford distance to the destination node:
    bfPathLengthsAll = dict(dist)
    bfPathLength = bfPathLengthsAll[destNode]

    #Return results by loading the list shared between processes.
    state.append({})
    args = state[0]
    args["pathLength"] = bfPathLength
    args["path"] = bfPath
    state[0] = args


############################################################
#
# The Dijkstra wrapper function
#
# This has been broken out of NetworkX function to make timing calculations
# more fine-grained and unique to the graph algorithm itself, not the 
# support code that loads the map and instantiates variables.
#
# This function is run as a separate process, to permit collection of memory
# consumption data due to complexity with the Python memory manager
# vs the OS memory manager. See the following links for details:
#
# http://stackoverflow.com/questions/23937189/how-do-i-use-subprocesses-to-force-python-to-release-memory/24126616#24126616
# https://docs.python.org/2/library/multiprocessing.html
# http://deeplearning.net/software/theano/tutorial/python-memory-management.html
#
@profile(precision=4)
def runDijkstra(state):

    input_data = state[0]["input_data"]
    debug = state[0]["debug"]

    #load NetworkX with adjacency matrix graph data (via Pandas)
    #G = nx.DiGraph( input_data.values ) #for directed graphs
    G = nx.Graph( input_data.values )  #for undirected graphs

    #Get list of nodes:
    nodeList = G.nodes()
    #nodeListData = G.nodes(data=True)
    #if debug: print("Node list length: %d" % len(nodeListData) )
    if debug: print("Node list length: %d" % len(nodeList) )

    #determine start and destination nodes for pathfinding purposes
    startNode = 1 #start node will always be node 1.
    #destNode = len(nodeListData)/2 + 1 #destination node will always be in the middle.
    destNode = len(nodeList)/2 + 1 #destination node will always be in the middle.
    #if debug: print ("Number of nodes in this graph: %d" % len(nodeListData) )
    #if debug: print ("Number of nodes in this graph: %d" % len(nodeList) )
    if debug: print ("Start node: %d.  Destination node: %d." % (startNode, destNode) )

    dijkstraPath = nx.dijkstra_path(G, startNode, destNode )
    #dijkstraPathLength = nx.dijkstra_path_length(G, startNode, destNode )
    dijkstraPathLength = len(dijkstraPath)

    #Return results by loading the list shared between processes.
    state.append({})
    args = state[0]
    args["pathLength"] = dijkstraPathLength
    args["path"] = dijkstraPath
    state[0] = args


############################################################

# Main Graph Generator Performance - Test Harness:
# This script assumes that graph files (in CSV format) have already been generated.
# If this is not the case, then the Python script: graph_generator.py
# See that script for more details.

def run_tests():

    #print ("In run_tests()")
    print ("\nUsage:\n %s [path to input CSV files] [algorithm: 1, 2, or 3] [showGraphs: 0 or 1] [debugMode: 0 or 1]\n" % str(sys.argv[0]) )
    print ("Where algorithm: 1 = A* (A-star), 2 = Bellman-Ford, 3 = Dijkstra.\n")
    print ("To save the output, redirect ('>') this program to file output.")
    print ("e.g.,\n  python  %s  inputSubDir  3  0  1  > ./temp/output.txt \n" % str(sys.argv[0]) )


    path = str(sys.argv[1])
    if isNotEmpty(path) == False:
        print("Target folder cannot be null or blank.")
        sys.exit(1)
    else:
        #verify if the path exists:
        if checkPath( path, False) == False:
            print("Target folder '%s' could not be found." % path)
            sys.exit(2)
        else:
            print("Found target folder: %s" % path)


    algorithm = int(sys.argv[2])
    if algorithm < 1: algorithm = 1
    if algorithm > 3: algorithm = 3
    algorithmName = ''
    if algorithm == 1: algorithmName = 'A-star'
    elif algorithm == 2: algorithmName = 'Bellman-Ford'
    elif algorithm == 3: algorithmName = 'Dijkstra'
    else: algorithmName = 'Unknown'


    displayGraphs = int(sys.argv[3])
    if displayGraphs == 1: displayGraphs = True
    elif displayGraphs == 0: displayGraphs = False
    else: displayGraphs = False


    debug = int(sys.argv[4])
    if debug == 1: debug = True
    elif debug == 0: debug = False
    else: debug = False

    advert = "(where 1 = A* (A-star), 2 = Bellman-Ford, 3 = Dijkstra)"
    print("Running with user-selected options:\n"),
    print("  inputFilePath=%s\n  algorithm=%d  %s\n  displayGraphs=%s\n  debug=%s\n" 
        % (path, algorithm, advert, displayGraphs, debug) )


    viewWidthInches = 10    #to do - parameterize this
    viewHeightInches = 10   #to do - parameterize this


    print("\nProcessing graph files (CSV format) in subdir: '%s'" % path)
    count = 0
    for root, dirs, files in os.walk (path):
        for fileName in files:
            if fileName.endswith('.csv'):
                count += 1

                #force a garbage collection before data collection.
                gc.enable()
                gc.collect()

                print ("ALGORITHM|%s" % algorithmName)
                print ("INFILECOUNTER|%d" % count)
                print ("INFILENAME|%s" % fileName)

                #call the function that does the pathfinding:
                elapsed_time = performNetworkXCalculations( fileName, path, algorithm, viewWidthInches, viewHeightInches, displayGraphs, debug )
                #elapsed_time = format( float(elapsed_time), '.2f')
                elapsed_time = format( float(elapsed_time), '.4f') #bring it all through, let subsequent scripts change precision as they need.
                #print("RESULTS|%s|elapsedTime(ms)|%f" % (algorithmName, elapsed_time*1000) )
                print("RESULTS|%s|elapsedTime|%s" % (algorithmName, elapsed_time) )

    print ("\nDone.\n")

    #mpLogFile.close()
"""


############################################################
#def heuristic(v, target, pos):
#
#    return sqrt(sum((pos[v].a - pos[target].a) ** 2))
#



############################################################
# Graph-Tool graph manipulations
#
# This function takes a simple GraphML text file name as input.
# The file itself should follow GraphML characteristics, discussed here:
# http://graphml.graphdrawing.org
#
# Warning: if drawGraph is True, it will write the graphs to the file system, one-by-one
# as they are processed for pathfinding operations. You will not see them on the screen.
# Additionally, this slows down the pathfinding operations!!!
# So, set the drawGraph parameter to true only during testing.
#
# The pathfinding algorithm parameter accepts a 1, 2, or 3, 
# which (alphabetical order) indicates the following:
#   1 = A* (A-star) algorithm   <--- this is the default
#   2 = Bellman-Ford algorithm
#   3 = Dijkstra's algorithm
#
def performGraphToolCalculations(graphmlFileName, path, algorithm=1, drawGraph=False, debug=False):

    """
    if algorithm == 1:
        print("\nRunning A-star search:")
        runAstar(fileName, path)
    elif algorithm == 2:
        print("\nRunning Bellman-Ford search:")
        runBellmanFord(fileName, path)
    elif algorithm == 3:
        print("\nRunning Dijkstra search:")
        runDijkstra(fileName, path)
    """


    algorithm = int(algorithm)
    drawGraph = bool(drawGraph)
    debug = bool(debug)

    if debug: print("Performing Graph-Tool pathfinding calculations...")

    #boundary checking:
    if algorithm < 1: algorithm = 1
    if algorithm > 3: algorithm = 3


    #Get the path to the target GraphML file:
    graphmlPathFile = os.path.join(path, graphmlFileName)


    start_time = 0.0

    #Now calculate the shortest paths, based on the user-specified algorithm.
    if algorithm == 1:
        if debug: print("Algorithm: A-Star")
        print("RESULTS|A-star|memoryConsumption(MB)|...\n")
        start_time = timeit.default_timer() #get the start time

        manager = multiprocessing.Manager()
        state = manager.list()
        state.append({})
        args = state[0]
        args["input_path_file"] = graphmlPathFile
        args["draw_graph"] = drawGraph
        args["debug"] = debug
        state[0] = args
        
        #start_time = timeit.default_timer() #get the start time
        #runAstar(G, startNode, destNode)
        p = multiprocessing.Process(target=runAstar, args=(state,) )
        p.start()
        p.join() #wait for child process to finish.
        print("RESULTS|A-star|pathLength|%d" % int(state[0]["pathLength"]) )
        print("RESULTS|A-star|path|%s" % str(state[0]["path"]) )

        end_time = timeit.default_timer() #get the end time
        elapsed_time = end_time - start_time
        
    elif algorithm == 2:
        if debug: print("Algorithm: Bellman-Ford")
        print("RESULTS|Bellman-Ford|memoryConsumption(MB)|...\n")
        start_time = timeit.default_timer() #get the start time

        manager = multiprocessing.Manager()
        state = manager.list()
        state.append({})
        args = state[0]
        args["input_path_file"] = graphmlPathFile
        args["draw_graph"] = drawGraph
        args["debug"] = debug
        state[0] = args
        
        #start_time = timeit.default_timer() #get the start time
        #runBellmanFord(G, startNode, destNode)
        p = multiprocessing.Process(target=runBellmanFord, args=(state,) )
        p.start()
        p.join() #wait for child process to finish.
        print("RESULTS|Bellman-Ford|pathLength|%d" % int(state[0]["pathLength"]) )
        print("RESULTS|Bellman-Ford|path|%s" % str(state[0]["path"]) )

        end_time = timeit.default_timer() #get the end time
        elapsed_time = end_time - start_time

    elif algorithm == 3:
        if debug: print("Algorithm: Dijkstra")
        print("RESULTS|Dijkstra|memoryConsumption(MB)|...\n")
        start_time = timeit.default_timer() #get the start time

        manager = multiprocessing.Manager()
        state = manager.list()
        state.append({})
        args = state[0]
        args["input_path_file"] = graphmlPathFile
        args["draw_graph"] = drawGraph
        args["debug"] = debug
        state[0] = args
        
        #start_time = timeit.default_timer() #get the start time
        #runDijkstra(G, startNode, destNode)
        p = multiprocessing.Process(target=runDijkstra, args=(state,) )
        p.start()
        p.join() #wait for child process to finish.
        print("RESULTS|Dijkstra|pathLength|%d" % int(state[0]["pathLength"]) )
        print("RESULTS|Dijkstra|path|%s" % str(state[0]["path"]) )

        end_time = timeit.default_timer() #get the end time
        elapsed_time = end_time - start_time



    #cleanup:
    #del input_data
    del graphmlPathFile
    
    #Done:
    return elapsed_time


############################################################
#
@profile(precision=4)
#def runAstar(fileName, debug=False):
def runAstar(state):

    print ("In runAstar()")
    
    input_path_file = state[0]["input_path_file"]
    draw_graph = state[0]["draw_graph"]
    debug = state[0]["debug"]

    print ("input_path_file = %s" % input_path_file)
    print ("draw_graph = %s" % draw_graph)
    print ("debugMode = %s" % debug)
    
    g = gt.Graph()
    g = gt.load_graph( input_path_file )
    
    #verts = g.vertices()
    #for v1 in verts:
    #    print(v1)
    
    #graph_draw(g, vertex_text=g.vertex_index, vertex_font_size=18, output_size=(300,300), output="small_100x100_k2_p05_1.png")
    
    #pos= sfdp_layout(g)
    #graph_draw(g, pos, output_size=(400,400), vertex_color=[1,1,1,0], vertex_size=10, edge_pen_width=1.2, output="gt_sfdp.png")
    
    #pos2= arf_layout(g, max_iter=0)
    #graph_draw(g, pos=pos2, output_size=(400,400), output="gt_arf.png")


    startNode = g.vertex(1) #always start at node index 1 (not zero)
    destNode = g.num_vertices()/2 + 1 # destination node is always halfway between first and last nodes


    #give all edges a weight of 1:
    weights = g.new_edge_property("int")
    #weight.set_value(1)
    for e in g.edges():
        weights[e] = 1
    
    
    dist, pred = gt.astar_search(g, startNode, weight=weights)
    #print ("Path length to destination node '%d' = %d" % (destNode, dist[int(destNode)] ) )

    #Graph-Tool's A* method doesn't return a simple path, nor
    # a path length. Instead it returns two lists: a predecessor, and a distance list.
    # So, we must do some list traversal to find the desired values:
    i = 0
    path = []   #build the list of node predecessors.
    for p in pred:
        path.append( [i, int(p)] )
        i += 1

    #destNode = g.vertex(51)
    #destNode = g.num_vertices()/2 + 1
    astarPath = []
    astarPath.append( int(destNode) ) # append the destination node, then find its predecessor.
    currNode = destNode #set current node to destination node

    #The following loop will start from the destination and work our way back to 
    # the start node, one node link at a time.
    # The predecessor list is in [int][int] format, specifically [index][pred node index],
    # so pred[99][1] means that while on the way to searching from the source to the
    # destination node, the node at index 99 has a predecessor of node index 1.
    while currNode != startNode:  #start with destination node...
        astarPath.append( path [int(currNode)][1] ) #append the predecessor node...
        currNode = path [int(currNode)][1]  #update the current node... keep looping backwards.
    astarPath.reverse() #now reverse the list, so it displays in correct order
    #print("A-Star Path = %s" % astarPath)
    #print("A-Star Path Length = %d" % (len(astarPath) -1) ) #subtract 1 to not count starting node.


    if draw_graph == True:
        #verts = g.vertices()
        #for v1 in verts:
            #print(v1)
    
        #graph_draw(g, vertex_text=g.vertex_index, vertex_font_size=18, output_size=(300,300), output="small_100x100_k2_p05_1.png")

        #pos = gt.sfdp_layout(g)
        #gt.graph_draw(g, pos, output_size=(800,800), vertex_color=[1,1,1,0], vertex_size=10, edge_pen_width=1.2, output=(input_path_file + ".png") )

        pos= gt.arf_layout(g, max_iter=0)
        gt.graph_draw(g, pos=pos, output_size=(800,800), vertex_color=[1,1,1,0], vertex_size=10, edge_pen_width=1.2, output=(input_path_file + ".png") )


    #Return results by loading the list shared between processes.
    state.append({})
    args = state[0]
    args["pathLength"] = len(astarPath) -1 #subtract 1 to not count starting node.
    args["path"] = astarPath
    state[0] = args


############################################################
@profile(precision=4)
def runBellmanFord(state):

    print ("In runBellmanFord()")
    
    input_path_file = state[0]["input_path_file"]
    draw_graph = state[0]["draw_graph"]
    debug = state[0]["debug"]

    print ("input_path_file = %s" % input_path_file)
    print ("draw_graph = %s" % draw_graph)
    print ("debugMode = %s" % debug)

    g = gt.Graph()
    g = gt.load_graph( input_path_file )
    
    
    #verts = g.vertices()
    #for v1 in verts:
    #    print(v1)
    
    #graph_draw(g, vertex_text=g.vertex_index, vertex_font_size=18, output_size=(300,300), output="small_100x100_k2_p05_1.png")
    
    #pos= sfdp_layout(g)
    #graph_draw(g, pos, output_size=(400,400), vertex_color=[1,1,1,0], vertex_size=10, edge_pen_width=1.2, output="gt_sfdp.png")
    
    #pos2= arf_layout(g, max_iter=0)
    #graph_draw(g, pos=pos2, output_size=(400,400), output="gt_arf.png")


    startNode = g.vertex(1)
    destNode = g.vertex(51)
    #print ("start node = " + str(startNode) + ", destination node = " + str(destNode) )


    #give all edges a weight of 1:
    weights = g.new_edge_property("int")
    #weight.set_value(1)
    for e in g.edges():
        weights[e] = 1


    #According to documentation, if negative_weights=True, then the shortest_path()
    # should start a Bellman_Ford path search (no specific weights property needed).
    # For documentation and details, see: https://graph-tool.skewed.de/static/doc/topology.html?highlight=shortest_path#graph_tool.topology.shortest_path
    vertList, edgeList = gt.shortest_path(g, startNode, destNode, negative_weights=True)


    shortestPath = []
    for v in vertList:
        #print (str(v))
        shortestPath.append( int(v) )


    ##print ("Bellman-Ford: Shortest path from nodes %s to %s =\n%s" % (startNode, destNode, str(shortestPath)) )
    #print ("Bellman-Ford Path = %s" % ( str(shortestPath)) )
    #print ("Bellman-Ford Path length = %d" % (len(shortestPath) -1) ) #subtract 1 to not count starting node.


    if draw_graph == True:
        #verts = g.vertices()
        #for v1 in verts:
            #print(v1)
    
        #graph_draw(g, vertex_text=g.vertex_index, vertex_font_size=18, output_size=(300,300), output="small_100x100_k2_p05_1.png")

        #pos = gt.sfdp_layout(g)
        #gt.graph_draw(g, pos, output_size=(800,800), vertex_color=[1,1,1,0], vertex_size=10, edge_pen_width=1.2, output=(input_path_file + ".png") )

        pos= gt.arf_layout(g, max_iter=0)
        gt.graph_draw(g, pos=pos, output_size=(800,800), vertex_color=[1,1,1,0], vertex_size=10, edge_pen_width=1.2, output=(input_path_file + ".png") )


    #Return results by loading the list shared between processes.
    state.append({})
    args = state[0]
    args["pathLength"] = len(shortestPath) -1 #subtract 1 to not count starting node.
    args["path"] = str(shortestPath)
    state[0] = args


############################################################
@profile(precision=4)
def runDijkstra(state):

    print ("In runDijkstra()")
    
    input_path_file = state[0]["input_path_file"]
    draw_graph = state[0]["draw_graph"]
    debug = state[0]["debug"]

    print ("input_path_file = %s" % input_path_file)
    print ("draw_graph = %s" % draw_graph)
    print ("debugMode = %s" % debug)
    
    g = gt.Graph()
    g = gt.load_graph( input_path_file )
    

    #verts = g.vertices()
    #for v1 in verts:
    #    print(v1)
    
    #graph_draw(g, vertex_text=g.vertex_index, vertex_font_size=18, output_size=(300,300), output="small_100x100_k2_p05_1.png")
    
    #pos= sfdp_layout(g)
    #graph_draw(g, pos, output_size=(400,400), vertex_color=[1,1,1,0], vertex_size=10, edge_pen_width=1.2, output="gt_sfdp.png")
    
    #pos2= arf_layout(g, max_iter=0)
    #graph_draw(g, pos=pos2, output_size=(400,400), output="gt_arf.png")


    #startNode = g.vertex(1)
    #destNode = g.vertex(51)
    #print ("start node = " + str(startNode) + ", destination node = " + str(destNode) )
    
    #Generic shortest path algorithm:
    #vertList, edgeList = shortest_path(g, startNode, destNode)
    #shortestPath = []
    #for v in vertList:
    #    #print (str(v))
    #    shortestPath.append( str(v) )
    
    
    #print ("Dijkstra: Shortest path from %s to %s =\n%s" % (startNode, destNode, str(shortestPath)) )
    #print ("Dijkstra: Path length = %d" % (len(shortestPath) -1) ) #subtract 1 to not count starting node.
    
    
    #for e in edgeList:
    #    print (str(e))


    startNode = g.vertex(1) #always start at node index 1 (not zero)
    #destNode = g.vertex(51)
    destNode = g.num_vertices()/2 + 1 # destination node is always halfway between first and last nodes


    weights = g.new_edge_property("int")
    #give all edges a weight of 1
    #weight.set_value(1)
    for e in g.edges():
        weights[e] = 1
    
    dist, pred = gt.dijkstra_search(g, startNode, weight=weights)
    #print (dist)
    #i = 0
    #for d in dist:
    #    print( "[%d: %s]" % (i, str(d)) ),
    #    i += 1
    #print ("Path length to destination node '%d' = %d" % (destNode, dist[int(destNode)] ) )


    #Graph-Tool's Dijkstra method doesn't return a simple path, nor
    # a path length. Instead it returns two lists: a predecessor, and a distance list.
    # So, we must do some list traversal to find the desired values:
    i = 0
    path = []   #build the list of node predecessors.
    for p in pred:
        path.append( [i, int(p)] )
        i += 1

    #destNode = g.vertex(51)
    dijkPath = []
    dijkPath.append( int(destNode) ) # append the destination node, then find its predecessor.
    currNode = destNode #set current node to destination node

    #The following loop will start from the destination and work our way back to 
    # the start node, one node link at a time.
    # The predecessor list is in [int][int] format, specifically [index][pred node index],
    # so pred[99][1] means that while on the way to searching from the source to the
    # destination node, the node at index 99 has a predecessor of node index 1.
    while currNode != startNode:  #start with destination node...
        dijkPath.append( path [int(currNode)][1] ) #append the predecessor node...
        currNode = path [int(currNode)][1]  #update the current node... keep looping backwards.
    dijkPath.reverse() #now reverse the list, so it displays in correct order
    #print("Dijkstra Path = %s" % dijkPath)
    #print("Dijkstra Path Length = %d" % (len(dijkPath) -1) ) #subtract 1 to not count starting node.


    if draw_graph == True:
        #verts = g.vertices()
        #for v1 in verts:
            #print(v1)
    
        #graph_draw(g, vertex_text=g.vertex_index, vertex_font_size=18, output_size=(300,300), output="small_100x100_k2_p05_1.png")

        #pos = gt.sfdp_layout(g)
        #gt.graph_draw(g, pos, output_size=(800,800), vertex_color=[1,1,1,0], vertex_size=10, edge_pen_width=1.2, output=(input_path_file + ".png") )

        pos= gt.arf_layout(g, max_iter=0)
        gt.graph_draw(g, pos=pos, output_size=(800,800), vertex_color=[1,1,1,0], vertex_size=10, edge_pen_width=1.2, output=(input_path_file + ".png") )


    #Return results by loading the list shared between processes.
    state.append({})
    args = state[0]
    args["pathLength"] = len(dijkPath) -1 #subtract 1 to not count starting node.
    args["path"] = dijkPath
    state[0] = args


############################################################

def main():

    print ("\nUsage:\n %s [path to input GraphML files] [algorithm: 1, 2, or 3] [drawGraphs: 0 or 1] [debugMode: 0 or 1]\n" % str(sys.argv[0]) )
    print ("Where algorithm: 1 = A* (A-star), 2 = Bellman-Ford, 3 = Dijkstra.\n")
    print ("To save the output, redirect ('>') this program to file output.")
    print ("e.g.,\n  python  %s  inputSubDir  1  0  0  > ./temp/output.txt \n" % str(sys.argv[0]) )


    path = str(sys.argv[1])
    if isNotEmpty(path) == False:
        print("Target folder cannot be null or blank.")
        sys.exit(1)
    else:
        #verify if the path exists:
        if checkPath( path, False) == False:
            print("Target folder '%s' could not be found." % path)
            sys.exit(2)
        else:
            print("Found target folder: %s" % path)


    algorithm = int(sys.argv[2])
    if algorithm < 1: algorithm = 1
    if algorithm > 3: algorithm = 3
    algorithmName = ''
    if algorithm == 1: algorithmName = 'A-star'
    elif algorithm == 2: algorithmName = 'Bellman-Ford'
    elif algorithm == 3: algorithmName = 'Dijkstra'
    else: algorithmName = 'Unknown'


    drawGraphs = int(sys.argv[3])
    if drawGraphs == 1: drawGraphs = True
    else: displayGraphs = False


    debug = int(sys.argv[4])
    if debug == 1: debug = True
    else: debug = False


    advert = "(where 1 = A* (A-star), 2 = Bellman-Ford, 3 = Dijkstra)"
    print("Running Graph-Tool pathfinding with user-selected options:\n"),
    print("  inputFilePath=%s\n  algorithm=%d  %s\n  drawGraphs=%s\n  debug=%s\n" 
        % (path, algorithm, advert, drawGraphs, debug) )


    print("\nProcessing GraphML graph files (text format) in subdir: '%s'" % path)
    count = 0
    for root, dirs, files in os.walk (path):
        for fileName in files:
            if fileName.endswith('.graphml'):
                count += 1

                #force a garbage collection before data collection.
                gc.enable()
                gc.collect()

                print ("ALGORITHM|%s" % algorithmName)
                print ("INFILECOUNTER|%d" % count)
                print ("INFILENAME|%s" % fileName)

                #call the function that does the pathfinding:
                elapsed_time = performGraphToolCalculations( fileName, path, algorithm, drawGraphs, debug )

                elapsed_time = format( float(elapsed_time), '.4f') #bring it all through, let subsequent scripts change precision as they need.
                print("RESULTS|%s|elapsedTime|%s" % (algorithmName, elapsed_time) )


    print ("\nDone.\n")


############################################################

if __name__ == '__main__':
    #print("In main()")
    main()
