import random
import math
import pandas as pd
import networkx as nx
import pylab
from pylab import rcParams
import sys
import os
import timeit
import functools
import gc
from memory_profiler import profile
from memory_profiler import memory_usage
from memory_profiler import LogFile
import guppy
import multiprocessing


"""
Program to read the small-world graphs generated by the graph generator script. 
It then loads the maps, one by one, into NetworkX to calculate 
shortest paths.

For reference, see:
http://stackoverflow.com/questions/6667201/how-to-define-two-dimensional-array-in-python
and
http://stackoverflow.com/questions/29192644/passing-a-multidimensional-array-to-a-function-in-python
and
http://stackoverflow.com/questions/29572623/plot-networkx-graph-from-adjacency-matrix-in-csv-file#29574772
and
http://stackoverflow.com/questions/5086430/how-to-pass-parameters-of-a-function-when-using-timeit-timer
"""

#globals:
#memory_profiler_out_file = 'memory_profiler.log'
##mpLogFile=open(memory_profiler_out_file,'w+')
#sys.stdout = LogFile(memory_profiler_out_file)


############################################################
def isNotEmpty(s):
    return bool(s and s.strip())


############################################################
def createFilePath( fileName, path, debug=False):

    #get path to this running Python script:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    if debug: print(">> script_dir = %s" % script_dir)
    
    #get path to output path + file:
    dest_dir = os.path.join(script_dir, path)
    if debug: print(">> dest_dir = %s" % dest_dir)
    
    #attempt to make the directory, if it doesn't already exist:
    try:
        os.makedirs(dest_dir)
        if debug: print(">> created directory: %s" % dest_dir)
    except OSError:
        if debug: print(">> directory already exists?: %s" % dest_dir )
        pass    #path already exists

    finalPathFileName = os.path.join( dest_dir, fileName )
    return finalPathFileName


############################################################
def checkFilePath( fileName, path, debug=False):

    #get path to this running Python script:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    if debug: print(">> script_dir = %s" % script_dir)
    
    #get path to output path + file:
    dest_dir = os.path.join(script_dir, path)
    if debug: print(">> dest_dir = %s" % dest_dir)
    
    #does path exist?
    if os.path.exists(dest_dir):
        
        #does target file exist?
        targetFile = os.path.join (dest_dir, fileName)
        if os.path.isfile(targetFile):
            if debug: print(">> found target file %s" % targetFile)
            return True
        else:
            print(">> target file %s does not exist." % targetFile)
            return False
    else: 
        print(">> path %s does not exist." % dest_dir)
        return False


############################################################
def checkPath( path, debug=False):

    #get path to this running Python script:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    if debug: print(">> script_dir = %s" % script_dir)
    
    #get path to input path:
    input_dir = os.path.join(script_dir, path)
    if debug: print(">> target dir = %s" % input_dir)
    
    #does path exist?
    if os.path.exists(input_dir):
        
        if debug: print(">> found target input path %s" % input_dir)
        return True
        
    else: 
        print(">> path %s does not exist." % input_dir)
        return False


############################################################
# NetworkX graph manipulations
#
# This function takes a simple adjacency matrix CSV file name as input.
# The adjacency matrix itself should have no label/column/row headers.
# It just needs the connection data, comma-delimited values. 
# E.g., an example of 3x3 adjacency matrix file contents:
#
#       1,0,0
#       0,1,1
#       1,0,0
#
# Warning: if showGraph is True, it will display the graphs, but one-by-one. You
# would have to serially close each graph window, for the next one to be generated
# and then be displayed, so you could then close that one... ad infinitum.
# So, set the showGraph parameter to true, only during testing.
#
# The pathfinding algorithm parameter accepts a 1, 2, or 3, 
# which (alphabetical order) indicates the following:
#   1 = A* (A-star) algorithm   <--- this is the default
#   2 = Bellman-Ford algorithm
#   3 = Dijkstra's algorithm
#
def performNetworkXCalculations(adjMatrixFileName, path, algorithm=1, viewWidth=10, viewHeight=10, showGraph=False, debug=False):

    algorithm = int(algorithm)
    viewWidth = int(viewWidth)
    viewHeight = int(viewHeight)
    showGraph = bool(showGraph)
    debug = bool(debug)

    if debug: print ("Performing NetworkX pathfinding calculations...")

    #boundary checking:
    if viewWidth < 0 or viewWidth > 16: viewWidth = 10
    if viewHeight < 0 or viewHeight > 10: viewHeight = 10
    if algorithm < 1: algorithm = 1
    if algorithm > 3: algorithm = 3

    csvPathFile = os.path.join(path, adjMatrixFileName)

    #read adjacency matrix file into pandas:
    #input_data = pd.read_csv(adjMatrixFileName, index_col=0)
    #input_data = pd.read_csv(adjMatrixFileName, header=None)
    input_data = pd.read_csv(csvPathFile, header=None)
    if debug: print ("\nPandas: input_data = \n%s" % input_data)

    """
    #load NetworkX with adjacency matrix graph data (via Pandas)
    #G = nx.grid_graph(dim=[10,10] )
    #G = nx.DiGraph( input_data.values ) #for directed graphs
    G = nx.Graph( input_data.values )  #for undirected graphs

    #Get list of nodes:
    nodeList = G.nodes()
    #print("Node list: \n %s") % nodeList
    nodeListData = G.nodes(data=True)
    if debug: print("Node list data: \n %s") % nodeListData
    if debug: print("Node list length: %d" % len(nodeListData) )

    #determine start and destination nodes for pathfinding purposes
    startNode = 1 #start node will always be node 1.
    destNode = len(nodeListData)/2 + 1 #destination node will always be in the middle.
    print ("Number of nodes in this graph: %d" % len(nodeListData) )
    print ("Start node: %d.  Destination node: %d." % (startNode, destNode) )
    """

    start_time = 0.0
        
    #Now calculate the shortest paths, based on the user-specified algorithm.
    if algorithm == 1:
        start_time = timeit.default_timer() #get the start time
        
        #runAstar(G, startNode, destNode)
        #runAstar(input_data, debug)
        
        manager = multiprocessing.Manager()
        state = manager.list()
        state.append({})
        args = state[0]
        args["input_data"] = input_data
        args["debug"] = debug
        state[0] = args
        p = multiprocessing.Process(target=runAstar, args=(state,) )
        p.start()
        p.join()
        print("A* results:")
        print(" pathlength = %d" % int(state[0]["pathLength"]) )
        print(" path = %s" % str(state[0]["path"]) )
        
        end_time = timeit.default_timer() #get the end time
        elapsed_time = end_time - start_time

    elif algorithm == 2:
        start_time = timeit.default_timer() #get the start time
        runBellmanFord(G, startNode, destNode)
        end_time = timeit.default_timer() #get the end time
        elapsed_time = end_time - start_time

    elif algorithm == 3:
        start_time = timeit.default_timer() #get the start time
        runDijkstra(G, startNode, destNode)
        end_time = timeit.default_timer() #get the end time
        elapsed_time = end_time - start_time
        #t = timeit.Timer(functools.partial(runDijkstra, G, startNode, destNode))
        #elapsed_time = t.timeit()

    if showGraph == True:
        #Prepare the graphical display. Set graph display to x,y screen inches:
        rcParams['figure.figsize'] = viewWidth, viewHeight
        nx.draw_circular(G, with_labels=True) #draw circular graph
        #nx.draw(G, with_labels=True)
        #nx.draw_spectral(G, with_labels=True)
        #nx.draw_spring(G, with_labels=True)
        #nx.draw_shell(G, with_labels=True)
        #nx.draw_networkx(G, with_labels=True)
        #nx.draw_random(G, with_labels=True)
        pylab.show() #show the graph to screen for viewing

    #cleanup:
    #del G
    #del nodeList
    #del nodeListData
    #del startNode
    #del destNode
    del input_data
    del csvPathFile
    
    #Done:
    return elapsed_time


############################################################
#
# The A-Star wrapper function
#
# This has been broken out of NetworkX function to make timing calculations
# more fine-grained and unique to the graph algorithm itself, not the 
# support code that loads the map and instantiates variables.
#
# This function is run as a separate process, to permit collection of memory
# consumption data due to complexity with the Python memory manager
# vs the OS memory manager. See the following links for details:
#
# http://stackoverflow.com/questions/23937189/how-do-i-use-subprocesses-to-force-python-to-release-memory/24126616#24126616
# https://docs.python.org/2/library/multiprocessing.html
# http://deeplearning.net/software/theano/tutorial/python-memory-management.html
#
@profile(precision=4)
#@profile(stream=mpLogFile)
#def runAstar(G, startNode, destNode):
#def runAstar(input_data, debug=False ):
def runAstar(state):

    input_data = state[0]["input_data"]
    debug = state[0]["debug"]
    #print(">> debug = " + str(debug) )
    
    #load NetworkX with adjacency matrix graph data (via Pandas)
    #G = nx.grid_graph(dim=[10,10] )
    #G = nx.DiGraph( input_data.values ) #for directed graphs
    G = nx.Graph( input_data.values )  #for undirected graphs

    #Get list of nodes:
    nodeList = G.nodes()
    #print("Node list: \n %s") % nodeList
    nodeListData = G.nodes(data=True)
    if debug: print("Node list data: \n %s") % nodeListData
    if debug: print("Node list length: %d" % len(nodeListData) )

    #determine start and destination nodes for pathfinding purposes
    startNode = 1 #start node will always be node 1.
    destNode = len(nodeListData)/2 + 1 #destination node will always be in the middle.
    if debug: print ("Number of nodes in this graph: %d" % len(nodeListData) )
    if debug: print ("Start node: %d.  Destination node: %d." % (startNode, destNode) )


    print("Using A* (A-star) algorithm for shortest path calculation.")
    aStarPath = nx.astar_path(G, startNode, destNode )
    #print ("aStarPath = %s") % aStarPath
    aStarPathLength = nx.astar_path_length(G, startNode, destNode )
    #print ("aStarPathLength = %d") % aStarPathLength
    ##print ("aStar: length of path list = %d") % ( len(aStarPath)-1 )


    #now prepare return results:
    state.append({})
    args = state[0]
    args["pathLength"] = aStarPathLength
    args["path"] = aStarPath
    state[0] = args


############################################################
#
# The Bellman-Ford wrapper function
##
# This has been broken out of NetworkX function to make timing calculations
# more fine-grained and unique to the graph algorithm itself, not the 
# support code that loads the map and instantiates variables.
#
#@profile(precision=4)
def runBellmanFord(G, startNode, destNode):

    print("Using Bellman-Ford algorithm for shortest path calculation.")
    pred, dist = nx.bellman_ford(G, startNode )
    #print ("bellmanFord: pred = %s") % sorted(pred.items())
    #print ("bellmanFord: dist = %s") % sorted(dist.items())
    #
    #1. NetworkX's Bellman-Ford method doesn't return a simple path, nor
    # a pathlength, like the A* and Dijkstra versions. It instead returns 
    # two lists: a predecessor, and a distance list.
    # So, we must do some list traversal to find the desired values that are
    # equivalent to the ones supported by A* and Dijkstra method versions:
    bfpath = [destNode] #start with destination node
    path = dict(pred) #convert predecessor list to K-V dictionary
    currNode = destNode #set current node to destination node
    #This following loop will start from the destination and work our way back to 
    # the start node, one node link at a time:
    while currNode != startNode:  #start with destination node...
        bfpath.append( path[currNode] ) #append the predecessor node...
        currNode = path[currNode] #update the current node... keep looping backwards.
    bfpath.reverse() #now reverse the list, so it displays in correct order
    print("bellmanFordPath = %s" % bfpath)
    #2. For Bellman-Ford distance, convert the dist list into a K-V dictionary, 
    # then search the dictionary for the destination node, 
    # then get that list entry's associated value.
    # this value represents the Bellman-Ford distance to the destination node:
    bfpathLength = dict(dist)
    print ("bellmanFordPathLength = %d" % bfpathLength[destNode] )


############################################################
#
# The Dijkstra wrapper function
#
# This has been broken out of NetworkX function to make timing calculations
# more fine-grained and unique to the graph algorithm itself, not the 
# support code that loads the map and instantiates variables.
#
#@profile(precision=4)
def runDijkstra(G, startNode, destNode):

    print("Using Dijkstra's algorithm for shortest path calculation.")
    dijkstraPath = nx.dijkstra_path(G, startNode, destNode )
    print ("dijkstraPath = %s") % dijkstraPath
    dijkstraPathLength = nx.dijkstra_path_length(G, startNode, destNode )
    print ("dijkstraPathLength = %d") % dijkstraPathLength
    #print ("dijkstra: length of path list = %d") % ( len(dijkstraPath)-1 )


############################################################

# Main Graph Generator Performance - Test Harness:
# This script assumes that graph files (in CSV format) have already been generated.
# If this is not the case, then the Python script: graph_generator.py
# See that script for more details.

def run_tests():

    #print ("In run_tests()")
    print ("\nUsage:\n %s [path to input CSV files] [algorithm: 1, 2, or 3] [showGraphs: 0 or 1] [debugMode: 0 or 1]\n" % str(sys.argv[0]) )
    print ("Where algorithm: 1 = A* (A-star), 2 = Bellman-Ford, 3 = Dijkstra.\n")
    print ("e.g.,\n  python  %s  inputSubDir  3  0  1\n" % str(sys.argv[0]) )


    path = str(sys.argv[1])
    if isNotEmpty(path) == False:
        print("Target folder cannot be null or blank.")
        sys.exit(1)
    else:
        #verify if the path exists:
        if checkPath( path, False) == False:
            print("Target folder '%s' could not be found." % path)
            sys.exit(2)
        else:
            print("Found target folder: %s" % path)


    algorithm = int(sys.argv[2])
    if algorithm < 1: algorithm = 1
    if algorithm > 3: algorithm = 3


    displayGraphs = int(sys.argv[3])
    if displayGraphs == 1: displayGraphs = True
    elif displayGraphs == 0: displayGraphs = False
    else: displayGraphs = False


    debug = int(sys.argv[4])
    if debug == 1: debug = True
    elif debug == 0: debug = False
    else: debug = False

    advert = "(where 1 = A* (A-star), 2 = Bellman-Ford, 3 = Dijkstra)"
    print("Running with options:\n  inputFilePath=%s\n  algorithm=%d  %s\n  displayGraphs=%s\n  debug=%s" % (path, algorithm, advert, displayGraphs, debug) )


    print("\nProcessing CSV files in subdir: '%s'" % path)
    count = 0
    for root, dirs, files in os.walk (path):
        for fileName in files:
            if fileName.endswith('.csv'):
                count += 1
                print ("\nProcessing File # %d:\nInput file name: '%s'" % (count, fileName) )
                viewWidthInches = 10    #to do - parameterize this
                viewHeightInches = 10   #to do - parameterize this

                #call the function that does the pathfinding:
                elapsed_time = performNetworkXCalculations( fileName, path, algorithm, viewWidthInches, viewHeightInches, displayGraphs, debug )
                print("Elapsed time (for algorithm %d): %f millisec" % (algorithm, elapsed_time*1000) )

                #force a garbage collection before next iteration:
                gc.enable()
                #print( "GC Count: ", )
                #print( gc.get_count() )
                gc.collect()

    print ("\nDone.\n")

    #mpLogFile.close()
    

############################################################

if __name__ == '__main__':
    #print("In main()")
    run_tests()
