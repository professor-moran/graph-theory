import random
import math
import pandas as pd
import networkx as nx
import pylab
from pylab import rcParams
import sys
import os
import timeit
import functools
import gc
from memory_profiler import profile
from memory_profiler import memory_usage
from memory_profiler import LogFile
import guppy
import multiprocessing


"""
Program to read the small-world graphs generated by the graph generator script. 
It then loads the maps, one by one, into NetworkX to calculate 
shortest paths.

Pipe the output to text file for subsequent parsing and reporting of the results.

For reference, see:
http://stackoverflow.com/questions/6667201/how-to-define-two-dimensional-array-in-python
and
http://stackoverflow.com/questions/29192644/passing-a-multidimensional-array-to-a-function-in-python
and
http://stackoverflow.com/questions/29572623/plot-networkx-graph-from-adjacency-matrix-in-csv-file#29574772
and
http://stackoverflow.com/questions/5086430/how-to-pass-parameters-of-a-function-when-using-timeit-timer
"""

#globals:
#memory_profiler_out_file = 'memory_profiler.log'
##mpLogFile=open(memory_profiler_out_file,'w+')
#sys.stdout = LogFile(memory_profiler_out_file)


############################################################
def isNotEmpty(s):
    return bool(s and s.strip())


############################################################
def createFilePath( fileName, path, debug=False):

    #get path to this running Python script:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    if debug: print("script_dir = %s" % script_dir)
    
    #get path to output path + file:
    dest_dir = os.path.join(script_dir, path)
    if debug: print("dest_dir = %s" % dest_dir)
    
    #attempt to make the directory, if it doesn't already exist:
    try:
        os.makedirs(dest_dir)
        if debug: print("created directory: %s" % dest_dir)
    except OSError:
        if debug: print("directory already exists?: %s" % dest_dir )
        pass    #path already exists

    finalPathFileName = os.path.join( dest_dir, fileName )
    return finalPathFileName


############################################################
def checkFilePath( fileName, path, debug=False):

    #get path to this running Python script:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    if debug: print("script_dir = %s" % script_dir)
    
    #get path to output path + file:
    dest_dir = os.path.join(script_dir, path)
    if debug: print("dest_dir = %s" % dest_dir)
    
    #does path exist?
    if os.path.exists(dest_dir):
        
        #does target file exist?
        targetFile = os.path.join (dest_dir, fileName)
        if os.path.isfile(targetFile):
            if debug: print("found target file %s" % targetFile)
            return True
        else:
            print("target file %s does not exist." % targetFile)
            return False
    else: 
        print("path %s does not exist." % dest_dir)
        return False


############################################################
def checkPath( path, debug=False):

    #get path to this running Python script:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    if debug: print("script_dir = %s" % script_dir)
    
    #get path to input path:
    input_dir = os.path.join(script_dir, path)
    if debug: print("target dir = %s" % input_dir)
    
    #does path exist?
    if os.path.exists(input_dir):
        
        if debug: print("found target input path %s" % input_dir)
        return True
        
    else: 
        print("Path %s does not exist." % input_dir)
        return False


############################################################
# NetworkX graph manipulations
#
# This function takes a simple adjacency matrix CSV file name as input.
# The adjacency matrix itself should have no label/column/row headers.
# It just needs the connection data, comma-delimited values. 
# E.g., an example of 3x3 adjacency matrix file contents:
#
#       1,0,0
#       0,1,1
#       1,0,0
#
# Warning: if showGraph is True, it will display the graphs, but one-by-one. You
# would have to serially close each graph window, for the next one to be generated
# and then be displayed, so you could then close that one... ad infinitum.
# So, set the showGraph parameter to true, only during testing.
#
# The pathfinding algorithm parameter accepts a 1, 2, or 3, 
# which (alphabetical order) indicates the following:
#   1 = A* (A-star) algorithm   <--- this is the default
#   2 = Bellman-Ford algorithm
#   3 = Dijkstra's algorithm
#
def performNetworkXCalculations(adjMatrixFileName, path, algorithm=1, viewWidth=10, viewHeight=10, showGraph=False, debug=False):

    algorithm = int(algorithm)
    viewWidth = int(viewWidth)
    viewHeight = int(viewHeight)
    showGraph = bool(showGraph)
    debug = bool(debug)

    if debug: 
        print("Performing NetworkX pathfinding calculations...")
        print("Adjacency Matrix File Name = %s" % adjMatrixFileName)
        print("Path = %s" % path)
        print("Algorithm = %d" % algorithm) #1 = Astar, 2 = BellmanFord, 3 = Dijkstra
        print("View Width = %s, Height = %s" % (viewWidth, viewHeight) )
        print("Show Graph = %s" % showGraph)


    #boundary checking:
    if viewWidth < 0 or viewWidth > 16: viewWidth = 10
    if viewHeight < 0 or viewHeight > 10: viewHeight = 10
    if algorithm < 1: algorithm = 1
    if algorithm > 3: algorithm = 3

    csvPathFile = os.path.join(path, adjMatrixFileName)

    #read adjacency matrix file into pandas:
    input_data = pd.read_csv(csvPathFile, header=None)
    #if debug: print ("\nPandas: input_data = \n%s" % input_data)

    start_time = 0.0

    #Now calculate the shortest paths, based on the user-specified algorithm.
    if algorithm == 1:
        if debug: print("Algorithm: A-Star")
        print("RESULTS|A-star|memoryConsumption(MB)|...\n")
        start_time = timeit.default_timer() #get the start time
        manager = multiprocessing.Manager()
        state = manager.list()
        state.append({})
        args = state[0]
        args["input_data"] = input_data
        args["debug"] = debug
        state[0] = args
        #start_time = timeit.default_timer() #get the start time
        #runAstar(G, startNode, destNode)
        p = multiprocessing.Process(target=runAstar, args=(state,) )
        p.start()
        p.join() #wait for child process to finish.
        print("RESULTS|A-star|pathLength|%d" % int(state[0]["pathLength"]) )
        print("RESULTS|A-star|path|%s" % str(state[0]["path"]) )
        end_time = timeit.default_timer() #get the end time
        elapsed_time = end_time - start_time

    elif algorithm == 2:
        if debug: print("Algorithm: Bellman-Ford")
        print("RESULTS|Bellman-Ford|memoryConsumption(MB)|...\n")
        start_time = timeit.default_timer() #get the start time
        manager = multiprocessing.Manager()
        state = manager.list()
        state.append({})
        args = state[0]
        args["input_data"] = input_data
        args["debug"] = debug
        state[0] = args
        #start_time = timeit.default_timer() #get the start time
        #runBellmanFord(G, startNode, destNode)
        p = multiprocessing.Process(target=runBellmanFord, args=(state,) )
        p.start()
        p.join() #wait for child process to finish.
        print("RESULTS|Bellman-Ford|pathLength|%d" % int(state[0]["pathLength"]) )
        print("RESULTS|Bellman-Ford|path|%s" % str(state[0]["path"]) )
        end_time = timeit.default_timer() #get the end time
        elapsed_time = end_time - start_time

    elif algorithm == 3:
        if debug: print("Algorithm: Dijkstra")
        print("RESULTS|Dijkstra|memoryConsumption(MB)|...\n")
        start_time = timeit.default_timer() #get the start time
        manager = multiprocessing.Manager()
        state = manager.list()
        state.append({})
        args = state[0]
        args["input_data"] = input_data
        args["debug"] = debug
        state[0] = args
        #start_time = timeit.default_timer() #get the start time
        #runDijkstra(G, startNode, destNode)
        p = multiprocessing.Process(target=runDijkstra, args=(state,) )
        p.start()
        p.join() #wait for child process to finish.
        print("RESULTS|Dijkstra|pathLength|%d" % int(state[0]["pathLength"]) )
        print("RESULTS|Dijkstra|path|%s" % str(state[0]["path"]) )
        end_time = timeit.default_timer() #get the end time
        elapsed_time = end_time - start_time

    if showGraph == True:
        #Prepare the graphical display. Set graph display to x,y screen inches:
        rcParams['figure.figsize'] = viewWidth, viewHeight
        G = nx.Graph( input_data.values ) 
        nx.draw_circular(G, with_labels=True) #draw circular graph
        #nx.draw(G, with_labels=True)
        #nx.draw_spectral(G, with_labels=True)
        #nx.draw_spring(G, with_labels=True)
        #nx.draw_shell(G, with_labels=True)
        #nx.draw_networkx(G, with_labels=True)
        #nx.draw_random(G, with_labels=True)
        pylab.show() #show the graph to screen for viewing


    #cleanup:
    del input_data
    del csvPathFile

    #Done:
    return elapsed_time


############################################################
#
# The A-Star wrapper function
#
# This has been broken out of NetworkX function to make timing calculations
# more fine-grained and unique to the graph algorithm itself, not the 
# support code that loads the map and instantiates variables.
#
# This function is run as a separate process, to permit collection of memory
# consumption data due to complexity with the Python memory manager
# vs the OS memory manager. See the following links for details:
#
# http://stackoverflow.com/questions/23937189/how-do-i-use-subprocesses-to-force-python-to-release-memory/24126616#24126616
# https://docs.python.org/2/library/multiprocessing.html
# http://deeplearning.net/software/theano/tutorial/python-memory-management.html
#
@profile(precision=4)
def runAstar(state):

    input_data = state[0]["input_data"]
    debug = state[0]["debug"]

    #load NetworkX with adjacency matrix graph data (via Pandas)
    #G = nx.DiGraph( input_data.values ) #for directed graphs
    G = nx.Graph( input_data.values )  #for undirected graphs

    #Get list of nodes:
    nodeList = G.nodes()
    #nodeListData = G.nodes(data=True)
    #if debug: print("Node list length: %d" % len(nodeListData) )
    if debug: print("Node list length: %d" % len(nodeList) )

    #determine start and destination nodes for pathfinding purposes
    startNode = 1 #start node will always be node 1.
    #destNode = len(nodeListData)/2 + 1 #destination node will always be in the middle.
    destNode = len(nodeList)/2 + 1 #destination node will always be in the middle.
    #if debug: print ("Number of nodes in this graph: %d" % len(nodeListData) )
    #if debug: print ("Number of nodes in this graph: %d" % len(nodeList) )
    if debug: print ("Start node: %d.  Destination node: %d." % (startNode, destNode) )

    aStarPath = nx.astar_path(G, startNode, destNode )
    #aStarPathLength = nx.astar_path_length(G, startNode, destNode )
    aStarPathLength = len(aStarPath)

    #Return results by loading the list shared between processes.
    state.append({})
    args = state[0]
    args["pathLength"] = aStarPathLength - 1 #subtract 1 to not include the source node
    args["path"] = aStarPath
    state[0] = args


############################################################
#
# The Bellman-Ford wrapper function
##
# This has been broken out of NetworkX function to make timing calculations
# more fine-grained and unique to the graph algorithm itself, not the 
# support code that loads the map and instantiates variables.
#
# This function is run as a separate process, to permit collection of memory
# consumption data due to complexity with the Python memory manager
# vs the OS memory manager. See the following links for details:
#
# http://stackoverflow.com/questions/23937189/how-do-i-use-subprocesses-to-force-python-to-release-memory/24126616#24126616
# https://docs.python.org/2/library/multiprocessing.html
# http://deeplearning.net/software/theano/tutorial/python-memory-management.html
#
@profile(precision=4)
def runBellmanFord(state):

    input_data = state[0]["input_data"]
    debug = state[0]["debug"]

    #load NetworkX with adjacency matrix graph data (via Pandas)
    #G = nx.DiGraph( input_data.values ) #for directed graphs
    G = nx.Graph( input_data.values )  #for undirected graphs

    #Get list of nodes:
    nodeList = G.nodes()
    #nodeListData = G.nodes(data=True)
    #if debug: print("Node list length: %d" % len(nodeListData) )
    if debug: print("Node list length: %d" % len(nodeList) )

    #determine start and destination nodes for pathfinding purposes
    startNode = 1 #start node will always be node 1.
    #destNode = len(nodeListData)/2 + 1 #destination node will always be in the middle.
    destNode = len(nodeList)/2 + 1 #destination node will always be in the middle.
    #if debug: print ("Number of nodes in this graph: %d" % len(nodeListData) )
    if debug: print ("Start node: %d.  Destination node: %d." % (startNode, destNode) )

    pred, dist = nx.bellman_ford(G, startNode )
    #print ("bellmanFord: pred = %s") % sorted(pred.items())
    #print ("bellmanFord: dist = %s") % sorted(dist.items())

    #1/2. NetworkX's Bellman-Ford method doesn't return a simple path, nor
    # a path length, like the A* and Dijkstra versions. It instead returns 
    # two lists: a predecessor, and a distance list.
    # So, we must do some list traversal to find the desired values that are
    # equivalent to the ones supported by A* and Dijkstra method versions:
    bfPath = [destNode] #start with destination node
    path = dict(pred) #convert predecessor list to K-V dictionary
    currNode = destNode #set current node to destination node
    #The following loop will start from the destination and work our way back to 
    # the start node, one node link at a time:
    while currNode != startNode:  #start with destination node...
        bfPath.append( path[currNode] ) #append the predecessor node...
        currNode = path[currNode] #update the current node... keep looping backwards.
    bfPath.reverse() #now reverse the list, so it displays in correct order
    #print("bellmanFordPath = %s" % bfpath)

    #2/2. For Bellman-Ford distance, convert the dist list into a K-V dictionary, 
    # then search the dictionary for the destination node, 
    # then get that list entry's associated value.
    # This value represents the Bellman-Ford distance to the destination node:
    bfPathLengthsAll = dict(dist)
    bfPathLength = bfPathLengthsAll[destNode]

    #Return results by loading the list shared between processes.
    state.append({})
    args = state[0]
    args["pathLength"] = bfPathLength #already includes a -1 for path length.
    args["path"] = bfPath
    state[0] = args


############################################################
#
# The Dijkstra wrapper function
#
# This has been broken out of NetworkX function to make timing calculations
# more fine-grained and unique to the graph algorithm itself, not the 
# support code that loads the map and instantiates variables.
#
# This function is run as a separate process, to permit collection of memory
# consumption data due to complexity with the Python memory manager
# vs the OS memory manager. See the following links for details:
#
# http://stackoverflow.com/questions/23937189/how-do-i-use-subprocesses-to-force-python-to-release-memory/24126616#24126616
# https://docs.python.org/2/library/multiprocessing.html
# http://deeplearning.net/software/theano/tutorial/python-memory-management.html
#
@profile(precision=4)
def runDijkstra(state):

    input_data = state[0]["input_data"]
    debug = state[0]["debug"]

    #load NetworkX with adjacency matrix graph data (via Pandas)
    #G = nx.DiGraph( input_data.values ) #for directed graphs
    G = nx.Graph( input_data.values )  #for undirected graphs

    #Get list of nodes:
    nodeList = G.nodes()
    #nodeListData = G.nodes(data=True)
    #if debug: print("Node list length: %d" % len(nodeListData) )
    if debug: print("Node list length: %d" % len(nodeList) )

    #determine start and destination nodes for pathfinding purposes
    startNode = 1 #start node will always be node 1.
    #destNode = len(nodeListData)/2 + 1 #destination node will always be in the middle.
    destNode = len(nodeList)/2 + 1 #destination node will always be in the middle.
    #if debug: print ("Number of nodes in this graph: %d" % len(nodeListData) )
    #if debug: print ("Number of nodes in this graph: %d" % len(nodeList) )
    if debug: print ("Start node: %d.  Destination node: %d." % (startNode, destNode) )

    dijkstraPath = nx.dijkstra_path(G, startNode, destNode )
    #dijkstraPathLength = nx.dijkstra_path_length(G, startNode, destNode )
    dijkstraPathLength = len(dijkstraPath)

    #Return results by loading the list shared between processes.
    state.append({})
    args = state[0]
    args["pathLength"] = dijkstraPathLength - 1 #subtract 1 to not include the source node
    args["path"] = dijkstraPath
    state[0] = args


############################################################
#
# Main NetworkX Graph Generator and Performance Test Harness:
# This script assumes that graph files (in CSV format) have already been generated
# by the script: graph_generator.py
#
def main():

    #print ("In run_tests()")
    print ("\nUsage:\n %s [path to input CSV files] [algorithm: 1, 2, or 3] [showGraphs: 0 or 1] [debugMode: 0 or 1] [forceGC: 0 or 1]\n" % str(sys.argv[0]) )
    print ("Where algorithm: 1 = A* (A-star), 2 = Bellman-Ford, 3 = Dijkstra.\n")
    print ("To save program output for parsing, redirect ('>') stdout to text file.")
    print ("e.g.,\n  python  %s  inputSubDir  3  0  1  0  >  ./temp/output.txt \n\n" % str(sys.argv[0]) )


    path = str(sys.argv[1])
    if isNotEmpty(path) == False:
        print("Target folder cannot be null or blank.")
        sys.exit(1)
    else:
        #verify if the path exists:
        if checkPath( path, False) == False:
            print("Target folder '%s' could not be found." % path)
            sys.exit(2)
        else:
            print("Found target folder: %s" % path)


    algorithm = int(sys.argv[2])
    if algorithm < 1: algorithm = 1
    if algorithm > 3: algorithm = 3
    algorithmName = ''
    if algorithm == 1: algorithmName = 'A-star'
    elif algorithm == 2: algorithmName = 'Bellman-Ford'
    elif algorithm == 3: algorithmName = 'Dijkstra'
    else: algorithmName = 'Unknown'


    displayGraphs = int(sys.argv[3])
    if displayGraphs == 1: displayGraphs = True
    else: displayGraphs = False


    debug = int(sys.argv[4])
    if debug == 1: debug = True
    else: debug = False


    forceGC = int(sys.argv[5])
    if forceGC == 1: forceGC = True
    else: forceGC = False
    print ("Forced garbage collection = %r" % forceGC)


    advert = "(where 1 = A* (A-star), 2 = Bellman-Ford, 3 = Dijkstra)"
    print("Running NetworkX pathfinding with user-selected options:\n"),
    print("  inputFilePath=%s\n  algorithm=%d  %s\n  displayGraphs=%s\n  debug=%s\n  forceGarbageCollection=%s\n" 
        % (path, algorithm, advert, displayGraphs, debug, forceGC) )


    viewWidthInches = 10    #to do - parameterize this
    viewHeightInches = 10   #to do - parameterize this


    print("\nProcessing graph files (CSV format) in subdir: '%s'" % path)
    count = 0
    for root, dirs, files in os.walk (path):
        for fileName in files:
            if fileName.endswith('.csv'):
                count += 1

                #Force a garbage collection before data collection:
                if forceGC:
                    gc.enable()
                    gc.collect()

                print ("ALGORITHM|%s" % algorithmName)
                print ("INFILECOUNTER|%d" % count)
                print ("INFILENAME|%s" % fileName)

                #call the function that does the pathfinding:
                elapsed_time = performNetworkXCalculations( fileName, path, algorithm, viewWidthInches, viewHeightInches, displayGraphs, debug )
                #elapsed_time = format( float(elapsed_time), '.2f')
                elapsed_time = format( float(elapsed_time), '.4f') #bring it all through, let subsequent scripts change precision as they need.
                #print("RESULTS|%s|elapsedTime(ms)|%f" % (algorithmName, elapsed_time*1000) )
                print("RESULTS|%s|elapsedTime|%s" % (algorithmName, elapsed_time) )

    print ("\nDone.\n")


############################################################

if __name__ == '__main__':
    main()
